//! SQLite database backend.

use std::cmp::Ordering;

use anyhow::{anyhow, Context, Result};
use diesel::{
    prelude::*,
    sql_query,
    sql_types::{Bool, Integer},
};
use diesel_migrations::{EmbeddedMigrations, MigrationHarness};

use crate::pocket::PocketItemId;

use super::{
    GetSavedItemsQuery, SavedItem, SavedItemSort, SavedItemStore, UpsertSavedItem, User, UserStore,
};

mod models;
// schema is auto-generated by diesel CLI, so skip formatting.
#[rustfmt::skip]
mod schema;

pub const MIGRATIONS: EmbeddedMigrations =
    diesel_migrations::embed_migrations!("migrations/sqlite");

impl From<models::User> for User {
    fn from(model: models::User) -> Self {
        Self {
            id: model.id,
            email: model.email,
            pocket_access_token: model.pocket_access_token,
            last_pocket_sync_time: model.last_pocket_sync_time,
        }
    }
}

pub struct DataStore {
    conn: SqliteConnection,
}

impl DataStore {
    pub fn new(conn: SqliteConnection) -> Self {
        Self { conn }
    }

    fn update_user_full<'a>(
        &mut self,
        id: i32,
        email: Option<&'a str>,
        pocket_access_token: Option<&'a str>,
        last_pocket_sync_time: Option<i64>,
    ) -> Result<()> {
        use schema::users::dsl::users;
        diesel::update(users.find(id))
            .set(&models::UpdateUser {
                email,
                pocket_access_token,
                last_pocket_sync_time,
            })
            .execute(&mut self.conn)?;
        Ok(())
    }
}

impl UserStore for DataStore {
    fn create_user<'a>(
        &mut self,
        email: &'a str,
        pocket_access_token: Option<&'a str>,
    ) -> Result<User> {
        let new_user = models::NewUser {
            email,
            pocket_access_token,
        };

        let user: User = self
            .conn
            .transaction::<_, diesel::result::Error, _>(|conn| {
                use schema::users::dsl;
                diesel::insert_into(schema::users::table)
                    .values(&new_user)
                    .execute(conn)?;

                dsl::users
                    .order(dsl::id.desc())
                    .limit(1)
                    .get_result::<models::User>(conn)
            })?
            .into();
        Ok(user)
    }

    fn get_user(&mut self, id: i32) -> Result<User> {
        use schema::users::dsl;
        let user = dsl::users
            .find(id)
            .get_result::<models::User>(&mut self.conn)?
            .into();
        Ok(user)
    }

    fn filter_users(&mut self, count: i32) -> Result<Vec<User>> {
        use schema::users::dsl;
        let users: Vec<User> = dsl::users
            .limit(count.into())
            .load::<models::User>(&mut self.conn)?
            .into_iter()
            .map(Into::into)
            .collect();
        Ok(users)
    }

    fn update_user<'a>(
        &mut self,
        id: i32,
        email: Option<&'a str>,
        pocket_access_token: Option<&'a str>,
    ) -> Result<()> {
        self.update_user_full(id, email, pocket_access_token, None)
    }

    fn update_user_last_pocket_sync_time(&mut self, id: i32, value: Option<i64>) -> Result<()> {
        self.update_user_full(id, None, None, value)
    }

    fn delete_user(&mut self, id: i32) -> Result<()> {
        use schema::users::dsl;
        diesel::delete(dsl::users.filter(dsl::id.eq(id))).execute(&mut self.conn)?;
        Ok(())
    }

    fn delete_all_users(&mut self) -> Result<()> {
        use schema::users::dsl;
        diesel::delete(dsl::users).execute(&mut self.conn)?;
        Ok(())
    }
}

impl From<models::SavedItem> for SavedItem {
    fn from(model: models::SavedItem) -> Self {
        Self {
            id: model.id,
            user_id: model.user_id,
            pocket_id: model.pocket_id,
            title: model.title,
            excerpt: model.excerpt,
            url: model.url,
            time_added: model.time_added,
        }
    }
}

impl DataStore {
    /// Retrieves all saved items for this user from the database.
    fn get_saved_items_by_user(&mut self, user_id: i32) -> Result<Vec<SavedItem>> {
        use self::schema::saved_items::dsl;
        let items: Vec<SavedItem> = dsl::saved_items
            .filter(dsl::user_id.eq(user_id))
            .load::<models::SavedItem>(&mut self.conn)?
            .into_iter()
            .map(Into::into)
            .collect();
        Ok(items)
    }
}

sql_function!(fn random() -> Text);

impl SavedItemStore for DataStore {
    fn create_saved_item<'a>(
        &mut self,
        user_id: i32,
        pocket_id: &'a PocketItemId,
        title: &'a str,
    ) -> Result<SavedItem> {
        let new_item = models::NewSavedItem {
            user_id,
            pocket_id,
            title,
            excerpt: None,
            url: None,
            time_added: None,
        };

        let item: SavedItem = self
            .conn
            .transaction::<_, diesel::result::Error, _>(|conn| {
                use schema::saved_items::dsl;
                diesel::insert_into(schema::saved_items::table)
                    .values(&new_item)
                    .execute(conn)?;

                dsl::saved_items
                    .order(schema::saved_items::id.desc())
                    .limit(1)
                    .get_result::<models::SavedItem>(conn)
            })?
            .into();
        Ok(item)
    }

    /// Creates or updates the saved item in the database.
    fn upsert_item(&mut self, item: &UpsertSavedItem) -> Result<()> {
        use schema::saved_items::dsl;

        let sqlite_upsert = models::NewSavedItem {
            user_id: item.user_id,
            pocket_id: item.pocket_id,
            title: item.title,
            excerpt: Some(item.excerpt),
            url: Some(item.url),
            time_added: Some(item.time_added),
        };

        diesel::insert_into(dsl::saved_items)
            .values(&sqlite_upsert)
            .on_conflict(dsl::pocket_id)
            .do_update()
            .set(&sqlite_upsert)
            .execute(&mut self.conn)?;

        Ok(())
    }

    fn get_item(&mut self, id: i32) -> Result<Option<SavedItem>> {
        use schema::saved_items::dsl;
        let item = dsl::saved_items
            .find(id)
            .get_result::<models::SavedItem>(&mut self.conn)
            .optional()?
            .map(Into::into);
        Ok(item)
    }

    fn get_items(&mut self, query: &GetSavedItemsQuery) -> Result<Vec<SavedItem>> {
        use schema::saved_items::dsl;

        let sqlite_query = dsl::saved_items.filter(dsl::user_id.eq(query.user_id));
        let sqlite_query = query.count.map_or_else(
            || sqlite_query.into_boxed(),
            |count| sqlite_query.limit(count).into_boxed(),
        );
        let sqlite_query = match query.sort_by {
            Some(SavedItemSort::TimeAdded) => sqlite_query.order(dsl::time_added),
            None => sqlite_query,
        };
        let items: Vec<SavedItem> = sqlite_query
            .load::<models::SavedItem>(&mut self.conn)?
            .into_iter()
            .map(Into::into)
            .collect();
        Ok(items)
    }

    fn get_items_by_keyword(&mut self, user_id: i32, keyword: &str) -> Result<Vec<SavedItem>> {
        // Find most relevant items by tf-idf.
        //
        // tf-idf stands for term frequency-inverse document frequency, which
        // rewards documents that contain more usage of uncommon terms in the
        // search query. https://en.wikipedia.org/wiki/Tf%E2%80%93idf
        //
        // This implementation uses tf(t, d) = count of t in d and idf(t, d, D)
        // = log_10(|D|/|{d in D : t in D}|).

        let user_saved_items = self.get_saved_items_by_user(user_id)?;
        let keyword_terms = keyword
            .split_whitespace()
            .map(str::to_lowercase)
            .collect::<Vec<_>>();

        // [[1, 2, 3], [0, 5, 1], ...]
        // For each doc (aka saved item), store the raw count of each word in
        // the doc.
        let mut term_freqs_by_doc = vec![vec![0; keyword_terms.len()]; user_saved_items.len()];
        // For each term, store the number of documents containing the term.
        let mut doc_freqs = vec![0; keyword_terms.len()];

        for (doc_i, saved_item) in user_saved_items.iter().enumerate() {
            // Calculate term-frequency for title.
            for word in saved_item.title.split_whitespace().map(str::to_lowercase) {
                for (term_i, term) in keyword_terms.iter().enumerate() {
                    if *term == word {
                        if term_freqs_by_doc[doc_i][term_i] == 0 {
                            doc_freqs[term_i] += 1;
                        }
                        term_freqs_by_doc[doc_i][term_i] += 1;
                    }
                }
            }

            // Calculate term-frequency for excerpt.
            if let Some(doc_excerpt) = &saved_item.excerpt {
                for word in doc_excerpt.split_whitespace().map(str::to_lowercase) {
                    for (term_i, term) in keyword_terms.iter().enumerate() {
                        if *term == word {
                            if term_freqs_by_doc[doc_i][term_i] == 0 {
                                doc_freqs[term_i] += 1;
                            }
                            term_freqs_by_doc[doc_i][term_i] += 1;
                        }
                    }
                }
            }

            // Calculate term-frequency for URL.
            if let Some(url) = &saved_item.url {
                let lower_url = url.to_lowercase();
                for (term_i, term) in keyword_terms.iter().enumerate() {
                    let count = lower_url.matches(term).count();
                    if count > 0 {
                        if term_freqs_by_doc[doc_i][term_i] == 0 {
                            doc_freqs[term_i] += 1;
                        }
                        term_freqs_by_doc[doc_i][term_i] += count;
                    }
                }
            }
        }

        let mut scores = term_freqs_by_doc
            .iter()
            .enumerate()
            .filter_map(|(doc_i, doc_term_counts)| {
                let score = doc_term_counts
                    .iter()
                    .enumerate()
                    .map(|(term_i, term_frequency)| {
                        *term_frequency as f64
                            * (user_saved_items.len() as f64 / (1.0 + f64::from(doc_freqs[term_i])))
                                .log10()
                    })
                    .sum::<f64>();

                if score.is_normal() {
                    Some((doc_i, score))
                } else {
                    // NaN, 0, subnormal scores get filtered out
                    None
                }
            })
            .collect::<Vec<_>>();
        scores.sort_unstable_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(Ordering::Equal));
        Ok(scores
            .iter()
            .map(|(i, _)| user_saved_items[*i].clone())
            .collect())
    }

    /// Returns random item without replacement.
    ///
    /// "Without replacement" is implemented via a temporary table.
    fn get_random_item(&mut self, user_id: i32) -> Result<Option<SavedItem>> {
        use diesel::dsl::sql;
        use schema::saved_items::dsl;
        let item = dsl::saved_items
            .filter(dsl::user_id.eq(user_id))
            .filter(sql::<Bool>(
                "id IN (SELECT id FROM (SELECT id FROM saved_items EXCEPT SELECT item_id FROM seen_items) ORDER BY RANDOM() LIMIT 1)"
            ))
            .get_result::<models::SavedItem>(&mut self.conn)
            .optional()?
            .map(Into::into);

        if let Some(SavedItem { id, .. }) = item {
            sql_query("INSERT INTO seen_items (item_id) VALUES (?)")
                .bind::<Integer, _>(id)
                .execute(&mut self.conn)?;
        }
        Ok(item)
    }

    /// Deletes the saved item from the database if the saved item exists.
    fn delete_item(&mut self, user_id: i32, pocket_id: &PocketItemId) -> Result<()> {
        use schema::saved_items::dsl;

        diesel::delete(
            dsl::saved_items
                .filter(dsl::user_id.eq(user_id))
                .filter(dsl::pocket_id.eq(pocket_id)),
        )
        .execute(&mut self.conn)?;
        Ok(())
    }

    /// Deletes all saved items from the database for the given user.
    fn delete_all(&mut self, user_id: i32) -> Result<()> {
        use schema::saved_items::dsl;

        diesel::delete(dsl::saved_items.filter(dsl::user_id.eq(user_id)))
            .execute(&mut self.conn)?;
        Ok(())
    }
}

impl super::DataStore for DataStore {}

/// Connects to the database and runs migrations.
pub fn initialize_db(database_url: &str) -> Result<SqliteConnection> {
    let mut conn = SqliteConnection::establish(database_url)
        .context("Failed to connect to SQLite database")?;
    sql_query("PRAGMA foreign_keys = ON").execute(&mut conn)?;
    conn.run_pending_migrations(MIGRATIONS)
        .map_err(|e| anyhow!(e))?;

    // Can't seem to use REFERENCES between TEMP and non-TEMP tables
    sql_query("CREATE TEMPORARY TABLE seen_items (id INTEGER PRIMARY KEY AUTOINCREMENT, item_id INTEGER NOT NULL)")
        .execute(&mut conn)
        .unwrap();
    Ok(conn)
}
