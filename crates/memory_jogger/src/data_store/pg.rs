//! Postgres database backend.

use std::{cmp::Ordering, rc::Rc};

use anyhow::{anyhow, Context, Result};
use diesel::prelude::*;
use diesel_migrations::{EmbeddedMigrations, MigrationHarness};

use crate::pocket::PocketItemId;

use super::{
    GetSavedItemsQuery, SavedItem, SavedItemSort, SavedItemStore, UpsertSavedItem, User, UserStore,
};

mod models;
// schema is auto-generated by diesel CLI, so skip formatting.
#[rustfmt::skip]
mod schema;

pub const MIGRATIONS: EmbeddedMigrations =
    diesel_migrations::embed_migrations!("migrations/postgres");

impl From<models::User> for User {
    fn from(model: models::User) -> Self {
        Self {
            id: model.id,
            email: model.email,
            pocket_access_token: model.pocket_access_token,
            last_pocket_sync_time: model.last_pocket_sync_time,
        }
    }
}

pub struct PgUserStore {
    conn: Rc<PgConnection>,
}

impl PgUserStore {
    pub fn new(conn: &Rc<PgConnection>) -> Self {
        Self {
            conn: Rc::clone(conn),
        }
    }

    fn update_user_full<'a>(
        &mut self,
        id: i32,
        email: Option<&'a str>,
        pocket_access_token: Option<&'a str>,
        last_pocket_sync_time: Option<i64>,
    ) -> Result<()> {
        use schema::users::dsl::users;
        diesel::update(users.find(id))
            .set(&models::UpdateUser {
                email,
                pocket_access_token,
                last_pocket_sync_time,
            })
            .execute(self.conn.as_ref())?;
        Ok(())
    }
}

impl UserStore for PgUserStore {
    fn create_user<'a>(
        &mut self,
        email: &'a str,
        pocket_access_token: Option<&'a str>,
    ) -> Result<User> {
        use self::schema::users;

        let new_user = models::NewUser {
            email,
            pocket_access_token,
        };

        let user: User = diesel::insert_into(users::table)
            .values(&new_user)
            .get_result::<models::User>(self.conn.as_ref())?
            .into();
        Ok(user)
    }

    fn get_user(&self, id: i32) -> Result<User> {
        use schema::users::dsl::users;
        let user = users
            .find(id)
            .get_result::<models::User>(self.conn.as_ref())?
            .into();
        Ok(user)
    }

    fn filter_users(&self, count: i32) -> Result<Vec<User>> {
        use schema::users::dsl;
        let users: Vec<User> = dsl::users
            .limit(count.into())
            .load::<models::User>(&*self.conn)?
            .into_iter()
            .map(Into::into)
            .collect();
        Ok(users)
    }

    fn update_user<'a>(
        &mut self,
        id: i32,
        email: Option<&'a str>,
        pocket_access_token: Option<&'a str>,
    ) -> Result<()> {
        self.update_user_full(id, email, pocket_access_token, None)
    }

    fn update_user_last_pocket_sync_time(&mut self, id: i32, value: Option<i64>) -> Result<()> {
        self.update_user_full(id, None, None, value)
    }

    fn delete_user(&mut self, id: i32) -> Result<()> {
        use schema::users::dsl;
        diesel::delete(dsl::users.filter(dsl::id.eq(id))).execute(self.conn.as_ref())?;
        Ok(())
    }

    fn delete_all_users(&mut self) -> Result<()> {
        use schema::users::dsl;
        diesel::delete(dsl::users).execute(self.conn.as_ref())?;
        Ok(())
    }
}

pub struct PgSavedItemStore {
    conn: Rc<PgConnection>,
}

impl From<models::SavedItem> for SavedItem {
    fn from(model: models::SavedItem) -> Self {
        Self {
            id: model.id,
            user_id: model.user_id,
            pocket_id: model.pocket_id,
            title: model.title,
            excerpt: model.excerpt,
            url: model.url,
            time_added: model.time_added,
        }
    }
}

impl PgSavedItemStore {
    pub fn new(conn: &Rc<PgConnection>) -> Self {
        Self {
            conn: Rc::clone(conn),
        }
    }

    /// Retrieves all saved items for this user from the database.
    fn get_saved_items_by_user(&self, user_id: i32) -> Result<Vec<SavedItem>> {
        use self::schema::saved_items::dsl;
        let saved_items: Vec<SavedItem> = dsl::saved_items
            .filter(dsl::user_id.eq(user_id))
            .load::<models::SavedItem>(self.conn.as_ref())?
            .into_iter()
            .map(Into::into)
            .collect();
        Ok(saved_items)
    }
}

sql_function!(fn random() -> Text);

impl SavedItemStore for PgSavedItemStore {
    fn create_saved_item<'a>(
        &mut self,
        user_id: i32,
        pocket_id: &'a PocketItemId,
        title: &'a str,
    ) -> Result<SavedItem> {
        use self::schema::saved_items;

        let new_post = models::NewSavedItem {
            user_id,
            pocket_id,
            title,
            excerpt: None,
            url: None,
            time_added: None,
        };

        let saved_item: SavedItem = diesel::insert_into(saved_items::table)
            .values(&new_post)
            .get_result::<models::SavedItem>(self.conn.as_ref())?
            .into();
        Ok(saved_item)
    }

    /// Creates or updates the saved item in the database.
    fn upsert_item(&mut self, item: &UpsertSavedItem) -> Result<()> {
        use schema::saved_items::dsl;

        let pg_upsert = models::NewSavedItem {
            user_id: item.user_id,
            pocket_id: item.pocket_id,
            title: item.title,
            excerpt: Some(item.excerpt),
            url: Some(item.url),
            time_added: Some(item.time_added),
        };

        diesel::insert_into(dsl::saved_items)
            .values(&pg_upsert)
            .on_conflict(dsl::pocket_id)
            .do_update()
            .set(&pg_upsert)
            .execute(&*self.conn)?;
        Ok(())
    }

    fn get_item(&self, id: i32) -> Result<Option<SavedItem>> {
        use schema::saved_items::dsl::saved_items;
        let item = saved_items
            .find(id)
            .get_result::<models::SavedItem>(self.conn.as_ref())
            .optional()?
            .map(Into::into);
        Ok(item)
    }

    fn get_items(&self, query: &GetSavedItemsQuery) -> Result<Vec<SavedItem>> {
        use schema::saved_items::dsl;

        let pg_query = dsl::saved_items.filter(dsl::user_id.eq(query.user_id));
        let pg_query = if let Some(count) = query.count {
            pg_query.limit(count).into_boxed()
        } else {
            pg_query.into_boxed()
        };
        let pg_query = match query.sort_by {
            Some(SavedItemSort::TimeAdded) => pg_query.order(dsl::time_added),
            None => pg_query,
        };
        let items: Vec<SavedItem> = pg_query
            .load::<models::SavedItem>(&*self.conn)?
            .into_iter()
            .map(Into::into)
            .collect();
        Ok(items)
    }

    fn get_items_by_keyword(&self, user_id: i32, keyword: &str) -> Result<Vec<SavedItem>> {
        // Find most relevant items by tf-idf.
        //
        // tf-idf stands for term frequency-inverse document frequency, which
        // rewards documents that contain more usage of uncommon terms in the
        // search query. https://en.wikipedia.org/wiki/Tf%E2%80%93idf
        //
        // This implementation uses tf(t, d) = count of t in d and idf(t, d, D)
        // = log_10(|D|/|{d in D : t in D}|).

        let user_saved_items = self.get_saved_items_by_user(user_id)?;
        let keyword_terms = keyword
            .split_whitespace()
            .map(str::to_lowercase)
            .collect::<Vec<_>>();

        // [[1, 2, 3], [0, 5, 1], ...]
        // For each doc (aka saved item), store the raw count of each word in
        // the doc.
        let mut term_freqs_by_doc = vec![vec![0; keyword_terms.len()]; user_saved_items.len()];
        // For each term, store the number of documents containing the term.
        let mut doc_freqs = vec![0; keyword_terms.len()];

        for (doc_i, saved_item) in user_saved_items.iter().enumerate() {
            // Calculate term-frequency for title.
            for word in saved_item.title.split_whitespace().map(str::to_lowercase) {
                for (term_i, term) in keyword_terms.iter().enumerate() {
                    if *term == word {
                        if term_freqs_by_doc[doc_i][term_i] == 0 {
                            doc_freqs[term_i] += 1;
                        }
                        term_freqs_by_doc[doc_i][term_i] += 1;
                    }
                }
            }

            // Calculate term-frequency for excerpt.
            if let Some(doc_excerpt) = &saved_item.excerpt {
                for word in doc_excerpt.split_whitespace().map(str::to_lowercase) {
                    for (term_i, term) in keyword_terms.iter().enumerate() {
                        if *term == word {
                            if term_freqs_by_doc[doc_i][term_i] == 0 {
                                doc_freqs[term_i] += 1;
                            }
                            term_freqs_by_doc[doc_i][term_i] += 1;
                        }
                    }
                }
            }

            // Calculate term-frequency for URL.
            if let Some(url) = &saved_item.url {
                let lower_url = url.to_lowercase();
                for (term_i, term) in keyword_terms.iter().enumerate() {
                    let count = lower_url.matches(term).count();
                    if count > 0 {
                        if term_freqs_by_doc[doc_i][term_i] == 0 {
                            doc_freqs[term_i] += 1;
                        }
                        term_freqs_by_doc[doc_i][term_i] += count;
                    }
                }
            }
        }

        let mut scores = term_freqs_by_doc
            .iter()
            .enumerate()
            .filter_map(|(doc_i, doc_term_counts)| {
                let score = doc_term_counts
                    .iter()
                    .enumerate()
                    .map(|(term_i, term_frequency)| {
                        *term_frequency as f64
                            * (user_saved_items.len() as f64 / (1.0 + doc_freqs[term_i] as f64))
                                .log10()
                    })
                    .sum::<f64>();

                if score.is_normal() {
                    Some((doc_i, score))
                } else {
                    // NaN, 0, subnormal scores get filtered out
                    None
                }
            })
            .collect::<Vec<_>>();
        scores.sort_unstable_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(Ordering::Equal));
        Ok(scores
            .iter()
            .map(|(i, _)| user_saved_items[*i].clone())
            .collect())
    }

    fn get_random_item(&self, user_id: i32) -> Result<Option<SavedItem>> {
        use schema::saved_items::dsl;
        let item = dsl::saved_items
            .filter(dsl::user_id.eq(user_id))
            .order(random())
            .get_result::<models::SavedItem>(self.conn.as_ref())
            .optional()?
            .map(Into::into);
        Ok(item)
    }

    /// Deletes the saved item from the database if the saved item exists.
    fn delete_item(&mut self, user_id: i32, pocket_id: &PocketItemId) -> Result<()> {
        use schema::saved_items::dsl;

        diesel::delete(
            dsl::saved_items
                .filter(dsl::user_id.eq(user_id))
                .filter(dsl::pocket_id.eq(pocket_id)),
        )
        .execute(&*self.conn)?;
        Ok(())
    }

    /// Deletes all saved items from the database for the given user.
    fn delete_all(&mut self, user_id: i32) -> Result<()> {
        use schema::saved_items::dsl;

        diesel::delete(dsl::saved_items.filter(dsl::user_id.eq(user_id))).execute(&*self.conn)?;
        Ok(())
    }
}

/// Connects to the database and runs migrations.
pub fn initialize_db(database_url: &str) -> Result<PgConnection> {
    let conn = PgConnection::establish(database_url)
        .context("Failed to connect to PostgreSQL database")?;
    conn.run_pending_migrations(MIGRATIONS)
        .map_err(|e| anyhow!(e))?;
    Ok(conn)
}
